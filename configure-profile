# TODO before executing anything, validate that the current shell is Bash as this configuration script is Bash specific.

# TODO check if Augeas can be used for the following purpose as it apparently could preserve formatting and location of edit. See https://stackoverflow.com/a/50323373/320594.
function remove_matching_line() {
    [ -f "$1" ] && sed -i.bak -e "/$2/d" $1 && rm ${1}.bak
}
# TODO evaluate not to remove previous matches in standard files as this could lead to syntax errors, e.g. if we match the whole content of an "if" clause, the following would delete its content producing a syntax problem. Prefer to perform the appropriate configuration overrides only from my own dedicated files, e.g. .bashrc_jh or .bash_profile_jh (but in that case perform a final removal of the entries I placed in the defaul shell configuration files, maybe by receiving the patterns in something like a 'old_patterns_to_delete' that removes previous entries only once in which case it will need a marker file or something like that to get sure of performing this only once).
function remove_all_matches() {
    remove_matching_line ~/.bashrc "$1"
    remove_matching_line ~/.bash_profile "$1"
    remove_matching_line ~/.profile "$1"
}
function append_bashrc() {
    remove_all_matches "$1"
    echo $2 >> ~/.bashrc
}
function append_profile_file() {
    remove_all_matches "$1"
    echo $2 >> ~/.bash_profile
}

function prepend_profile_file() {
    remove_all_matches "$1"
    sed -i.bak -e "1s;^;$2\n;" ~/.bash_profile && rm ~/.bash_profile.bak
}

function is_interactive_shell() {
  [[ $- == *i* ]]
}

if is_interactive_shell; then
  # TODO support other OSses, e.g. macOS with Homebrew.
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    if command -v apt &>/dev/null; then
      sudo apt update -qq
      # TODO make the following less verbose carefully.
      sudo apt install -qqq -y screen cron python3-pip emacs-nox vim curl
    fi
  fi
else
  echo "Not an interactive terminal. Not installing required software."
fi

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

######
# Shell configuration
# TODO try to keep all shell configuration edits in blocks to make it easier to visually identify the configurations being managed from here or even better use dedicated files files and just source them, i.e. .bashrc_jh .bash_profile_jh. See https://superuser.com/a/224204/89031. Check if this might be somehow related too https://github.com/AlbanAndrieu/ansible-shell/blob/master/templates/.bashrc.j2.
######
# TODO look for the way to prevent sourcing .bashrc if it has been already sourced with the code in the default .bash_profile.
append_profile_file '^source "${HOME}\/.bashrc"' 'source "${HOME}/.bashrc"'

# TODO confirm that the colors for the prompt are really compatible across terminals in different systems: macOS, multiple Linux servers, Linux for Desktop, Termius for iOS and Desktop, etc.
# TODO Look for the way to root sessions to be prompted in a different color to reflect warning, e.g. all the prompt could be painted in red.
# TODO check why are two backslashes apparently required before $ while it isn't required for the other escapes as \n. Check TLCL on this.
# TODO try to print the exit code of the previous command while maintaining the previous command exit code in $? in case the user wants to do "echo $?".
# Colors borrowed from the defaults in Debian 11.
append_bashrc '^PS1=' 'PS1="\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\n\\$ "'

# Updating aliases. It has been observed that .bash_aliases is named .alias in systems like openSUSE, so we prefer to use .bash_aliases_jh just to keep it agnostic from every different distribution.
cp $DIR/.bash_aliases_jh ~/.bash_aliases_jh
. ~/.bash_aliases_jh
append_bashrc '\.bash_aliases_jh' "test -s ~/.bash_aliases_jh && . ~/.bash_aliases_jh || true"
test -s ~/.bash_aliases && echo "WARNING: .bash_aliases already exists. Check if there are old definitions to delete there."
test -s ~/.alias && echo "WARNING: .alias already exists. Manually check if there are old definitions to delete there."

# Updating preferred editor
# TODO confirm that the profile file is the more correct place to set the EDITOR, e.g. instead of .bashrc (where these variables might not require to be exported). See https://unix.stackexchange.com/a/129144/11564.
append_profile_file 'export VISUAL' 'export VISUAL=emacs; export EDITOR="$VISUAL"; export GIT_EDITOR="$VISUAL"'
# TODO instead of overwritting ~/.emacs, evaluate to just include a file like ~/.emacs_jh from it, so it is still possible to customize Emacs settings in each server.
cp $DIR/.emacs ~/.emacs

# We use Vim as well.
# See the TODOS for the similar .emacs.
cp $DIR/.vimrc ~/.vimrc

# TODO try to include a custom ~/.screenrc_jh from the main ~/.screenrc instead of overwriting
# TODO maybe indicate/warn if this file was "updated" or "overwritten"
cp $DIR/.screenrc ~/.screenrc
# Starting screen automatically on login
append_profile_file 'screen -R' 'if [ -z "$JHLP_NO_AUTOLOAD_SCREEN" ] && [ -z "$STY" ]; then screen -R; fi'

# Removing remnants of: Close Bash sessions after $BASH_IDLE_SESSION_TIMEOUT seconds of inactivity.
remove_all_matches '^BASH_IDLE_SESSION_TIMEOUT='
remove_all_matches 'unset TMOUT'

# We are putting the HIST* variables at the beginning of ~/.bash_profile given that it is the first file that is sourced when a new login shell is started and it is important to ensure that these variables are set before anything else, otherwise an error later during initialization could produce unintended history truncation, e.g. it has been observed that if the Bash completion initialization hangs forever (e.g. when Docker is set to a non-available context), if the HIST* variables are not already set, when the terminal is closed, truncation to the default 500 lines occurs for the Bash history file.
prepend_profile_file 'HISTCONTROL=' 'HISTCONTROL=ignoreboth'
# About the "DUMMY" value, see https://superuser.com/questions/1446920/setting-bash-history-sizes-to-1-clears-the-history.
prepend_profile_file 'HISTSIZE=' "HISTSIZE='DUMMY'"
prepend_profile_file 'HISTFILESIZE=' "HISTFILESIZE='DUMMY'"

# TODO when creating .bashrc_jh, evaluate to allow my customizations to run only once by using a variable like $JHLP_BASHRC_LOADED, but maybe there is no real problem with allowing my .bashrc configurations to load several times.

append_bashrc "stty -ixon" "stty -ixon"

# Removing the umask previously set to 027 as it was observed generating problems (IIRC). See too https://unix.stackexchange.com/questions/781/downsides-of-umask-077/551277#551277.
# TODO retire the following in a while to allow the umask to be modified selectively on each host.
remove_all_matches "^umask"

# The results of history substitution are not immediately passed to the shell parser.
append_bashrc "shopt -s histverify" "shopt -s histverify"

#######
# Updating authorized SSH keys
#######
mkdir -p ~/.ssh/
cp $DIR/authorized_keys_global ~/.ssh/authorized_keys
chmod 700 ~/.ssh
chmod 600 ~/.ssh/authorized_keys
if [ -f ~/.ssh/authorized_keys_host_specific ]; then
    cat ~/.ssh/authorized_keys_host_specific >> ~/.ssh/authorized_keys
fi

####
# Git configuration
####
git config --global user.name "Jaime Hablutzel"
git config --global user.email "hablutzel1@gmail.com"
# Recommended value for Unix like systems.
git config --global core.autocrlf input

# TODO evaluate to create a global exclude for .DS_Store files on macOS. See blobfish-72 .gitconfig as reference.

# TODO maybe link the full 'hooks' directory instead of each hook.
# Git hook to execute this script automatically when pulling changes.
ln -sf ../../git_hooks/post-merge $DIR/.git/hooks/post-merge

####
# User crontab configuration
####
tmpcronfile=$(mktemp)
crontab -l >"$tmpcronfile"
sed -i.bak -e '/.codex-cli/d' $tmpcronfile && rm ${tmpcronfile}.bak
sed -i.bak -e '/.jaime-hablutzel-linux-profile/d' $tmpcronfile && rm ${tmpcronfile}.bak
# TODO instead of keep adding preceding newlines, just verify that the file is terminated in a new line before appending the command.
echo >> $tmpcronfile
# TODO check better the -q and STDERR supression for "git pull", e.g. it has been observed that the "echo"s in the current file are being output to STDERR when ran as part of the Git hook execution, but is this the expected behavior?.
# TODO instead of supressing STDERR, evaluate to always send it to a Git ignored file under ~/.jaime-hablutzel-linux-profile/ to avoid totally losing possible errors like "fatal: unable to access 'https://github.com/hablutzel1/jaime-hablutzel-linux-profile.git/': The requested URL returned error: 504".
#echo "0 1 * * * cd ~/.codex-cli/ && git pull -q 2>/dev/null" >>$tmpcronfile
echo "*/5 * * * * cd ~/.jaime-hablutzel-linux-profile/ && git pull -q 2>/dev/null" >> $tmpcronfile
crontab $tmpcronfile
rm -f $tmpcronfile

######
# Codex CLI configuration
######
if [ -d ~/.codex-cli ]; then
  # TODO re-enable the auto-pull after having an stable and trusted version of Codex CLI available.
  # bash -c 'cd ~/.codex-cli && git pull'
  :
else
  git clone https://github.com/AntonOsika/CLI-Co-Pilot.git ~/.codex-cli
  # Not fully trusting this fork so we are checking out a specific commit.
  bash -c 'cd ~/.codex-cli && git reset --hard 047d034873e62310e07ff50a3cbb72c1b6eb230b'
fi

# TODO check carefully the following warning and remove it: "WARNING: The script openai is installed in '/home/vagrant/.local/bin' which is not on PATH. Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
python3 -m pip install --upgrade -q --user -r ~/.codex-cli/requirements.txt

if [ ! -f ~/.codex-cli/src/openaiapirc ]; then
  if is_interactive_shell; then
    # FIXME provide another way to skip Codex CLI setup instead of suggesting CTRL+C which halts the rest of the execution of this script.
    echo "Please provide the Codex CLI secret key (or CTRL+C to skip Codex CLI setup):"
    read -s codex_cli_password
    # TODO check if exposing my organization ID like this is safe.
    # FIXME after it is ran, triggering path completion with TAB makes the current shell suddenly close.
    source ~/.codex-cli/scripts/bash_setup.sh -o org-kjPMSPjdRG1kG4YtjPq6DRzV -k "$codex_cli_password" -e gpt-3.5-turbo
    # TODO evaluate to activate the multi-turn mode by default, but first get sure that it is safe by using it extensively. See https://github.com/microsoft/Codex-CLI/blob/main/README.md#usage.
  else
    echo "Not trying to set up Codex CLI as it requires an interactive shell to receive the secret key."
  fi
else
  echo "Codex CLI already configured."
fi


echo "Jaime Hablutzel's configuration applied."
